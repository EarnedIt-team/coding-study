import java.util.*;

class Solution {
    public int solution(int n, int k, int[] enemy) {
        // n을 enemy[i]만큼 차감, 그 중 k번은 차감 패스 가능, 차감불가 시점 노카운트 종료 & 최대한 높은 i+1은?
        // 그리디 가능.. ? 깊우탐? 인덱스 저장 후 정렬? 이건 불가할듯 / 숫자가 굉장히 높다. 깊우탐은 터질듯 .. 
        // 패스를 언제 쓸지는 미리 정할 수 없지만 이미 지나간 라운드를 기억했다가 패스 쓰기 가능
        // -> 일단 차감 계속 하다가 차감 불가 시점에 지난 것들 중 제일 높은애 하나씩 디펜스처리하고(수도 되돌리고) 더 차감 가능한지 보기
        
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());

        for (int i = 0; i < enemy.length; i++) {
            n -= enemy[i];
            pq.offer(enemy[i]);

            if (n < 0) {
                if (k == 0) return i;

                n += pq.poll(); // 가장 큰 적을 무적 처리
                k--;
            }
        }

        return enemy.length;
    }
}