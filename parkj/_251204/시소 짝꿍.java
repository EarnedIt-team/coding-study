import java.util.*;

class Solution {
    public long solution(int[] weights) {
        long answer = 0;

        // 거리 조합 (같은 비율 통합 {2,2}, {3,3}, {4,4} => {1,1})
        int[][] miters = {{1, 1}, {2, 3}, {2, 4}, {3, 2}, {3, 4}, {4, 2}, {4, 3}};  
            
        // "이미 등장한" 몸무게들의 개수 저장
        // 명단이라고 생각하면 됨
        Map<Integer, Integer> roster = new HashMap<>();

        // 한 명씩 검사
        // 사람1(w) x 거리1 = 사람2 x 거리2
        // 사람2 = 사람1 x 거리1/거리2
        // 즉, 지금 몸무게(w1, 사람1)의 거리 비율에 따라 평행이 되는 몸무게(w2, 사람2)값이 나오게 됨
        for (int w1 : weights) {
                       
            // 거리조합을 기반으로 하나씩 처리
            for (int[] m : miters) {
                // 나누어 떨어질 때만 유효한 짝 (몸무게는 정수이기 때문에)
                if (w1 * m[0] % m[1] == 0) {
                    int w2 = w1 * m[0] / m[1]; // 짝이 될 몸무게

                    // 이미 등장한 짝의 개수만큼 더함
                    // 초기에는 등록된 몸무게가 없기에 0으로 설정
                    // 다음사람부터 과거에 등록된 사람과 비교해서 처리하게 됨
                    
                    // ex. 1번째 사람은 "100kg"이었고 자신과 짝이 되는 경우는 100kg인데
                    // 본인이 처음이었기에 짝이 되는 사람을 찾지 못함
                    // 이후, 4번째 사람이 "100kg"이었고 자신과 짝이 되는 경우는 100kg인데
                    // 과거에 100kg으로 등록한 사람이 있었기에 카운트가 가능해짐
                    answer += roster.getOrDefault(w2, 0);
                }
            }

            // 현재 몸무게를 map에 등록
            // [100,180,360,100,270]
            // {100:2, 180:1 ....}
            roster.put(w1, roster.getOrDefault(w1, 0) + 1);
        }

        return answer;
    }
}
